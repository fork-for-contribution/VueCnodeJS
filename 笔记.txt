src
├── App.vue                 // 项目的入口 Vue 文件
├── assets                  // 图片，字体，公共样式
├── components
│   ├── Content.vue
│   ├── Divider.vue
│   ├── Header.vue
│   ├── OtherTopic.vue
│   ├── ProfilePanel.vue
│   ├── RecentReply.vue
│   └── Reply.vue
├── main.js                 // 项目的入口 js 文件
├── plugins
│   └── element.js          // 初始化用到的组件
├── router.js               // vue-router
├── utils
│   ├── api.js              // 获取数据
│   ├── eventProxy.js
│   ├── request.js          // 封装 axios
│   ├── tab.js
│   └── util.js
└── views
    ├── Home.vue
    ├── Topic.vue
    └── User.vue



在引入一些插件时，需要调用 Vue.use()。

有些插件需要用 Vue.use 才能用，有些直接使用。

如果插件有 install 方法：
export const testObj = {
    install(Vue, arg) {
    }
}
就要使用 Vue.use() 初始化这个插件。
这样写的好处就是插件初始需要调用的方法都封装在 install 里，更加精简和可拓展性更高。

如果封装的插件是靠这个对象去调用方法，比如 axios，那么直接用的就是 export default 暴露出一个对象，那么就不需要使用 Vue.use。


https://segmentfault.com/a/1190000012296163
编写插件的时候可以有两种方式：

1，将这个插件的逻辑封装成一个对象，最后在 install 编写业务代码暴露给 Vue 对象。这样做的好处是可以添加任意参数在这个对象上方便将 install 函数封装得更加精简，可拓展性也比较高。
export const Plugin = {
    install(Vue) {
        Vue.component...
        Vue.mixins...
        Vue...
        // 可以在 install() 里执行其他函数，Vue 会将 this 指向我们的插件
        console.log(this)  // {install: ...,utils: ...}
        this.utils(Vue)    // 执行utils函数
        console.log(this.COUNT) // 0
    },
    utils(Vue) {
        Vue...
        console.log(Vue)  // Vue
    },
    COUNT: 0
}
// 可以在这个对象上添加参数，最终 Vue 只会执行 install 方法，而其他方法可以作为封装 install 方法的辅助函数

2，将所有逻辑都编写成一个函数暴露给 Vue。
const test = 'test'
export function Plugin2(Vue) {
    Vue...
    console.log(test)  // 'test'
    // 如果插件编写成函数形式，那么 Vue 只会把 this 指向 null，并不会指向这个函数
    console.log(this)  // null
}
// 这种方式我们只能在一个函数中编写插件逻辑，可封装性就不是那么强了


